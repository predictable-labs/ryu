-DATASET CSV empty
--

-CASE CreateHNSWAutoCommit
-SKIP_IN_MEM
-LOAD_DYNAMIC_EXTENSION vector
-STATEMENT CREATE NODE TABLE embeddings (id int64, vec FLOAT[8], PRIMARY KEY (id));
---- ok
-STATEMENT CALL threads=1;
---- ok
-STATEMENT CALL auto_checkpoint=false;
---- ok
-STATEMENT CALL force_checkpoint_on_close=false;
---- ok
-STATEMENT COPY embeddings FROM "${RYU_ROOT_DIRECTORY}/dataset/embeddings/embeddings-8-1k.csv" (deLim=',');
---- ok
-STATEMENT CALL CREATE_VECTOR_INDEX('embeddings', 'e_hnsw_index','vec', metric := 'l2');
---- ok
-STATEMENT CALL QUERY_VECTOR_INDEX('embeddings', 'e_hnsw_index',CAST([0.1521,0.3021,0.5366,0.2774,0.5593,0.5589,0.1365,0.8557],'FLOAT[8]'), 3) RETURN node.id ORDER BY distance;
-CHECK_ORDER
---- 3
333
444
133
-RELOADDB
-LOAD_DYNAMIC_EXTENSION vector
-STATEMENT CALL QUERY_VECTOR_INDEX('embeddings', 'e_hnsw_index',CAST([0.1521,0.3021,0.5366,0.2774,0.5593,0.5589,0.1365,0.8557],'FLOAT[8]'), 3, efs := 500) RETURN node.id ORDER BY distance;
-CHECK_ORDER
---- 3
333
444
133

-CASE CreateHNSWComit
-LOAD_DYNAMIC_EXTENSION vector
-STATEMENT BEGIN TRANSACTION;
---- ok
-STATEMENT CREATE NODE TABLE embeddings (id int64, vec FLOAT[8], PRIMARY KEY (id));
---- ok
-STATEMENT COPY embeddings FROM "${RYU_ROOT_DIRECTORY}/dataset/embeddings/embeddings-8-1k.csv" (deLim=',');
---- ok
-STATEMENT CALL CREATE_VECTOR_INDEX('embeddings', 'e_hnsw_index','vec', metric := 'l2');
---- error
Binder exception: CREATE_VECTOR_INDEX is only supported in auto transaction mode.
# -STATEMENT CALL QUERY_VECTOR_INDEX('embeddings', 'e_hnsw_index',CAST([0.1521,0.3021,0.5366,0.2774,0.5593,0.5589,0.1365,0.8557],'FLOAT[8]'), 3) RETURN node.id ORDER BY distance;
# -CHECK_ORDER
# ---- 3
# 333
# 444
# 133
# -STATEMENT COMMIT;
# ---- ok

-CASE DropHNSWComit
-LOAD_DYNAMIC_EXTENSION vector
-STATEMENT CREATE NODE TABLE embeddings (id int64, vec FLOAT[8], PRIMARY KEY (id));
---- ok
-STATEMENT COPY embeddings FROM "${RYU_ROOT_DIRECTORY}/dataset/embeddings/embeddings-8-1k.csv" (deLim=',');
---- ok
-STATEMENT CALL CREATE_VECTOR_INDEX('embeddings', 'e_hnsw_index','vec', metric := 'l2');
---- ok
-STATEMENT BEGIN TRANSACTION;
---- ok
-STATEMENT CALL DROP_VECTOR_INDEX('embeddings', 'e_hnsw_index');
---- ok
-STATEMENT COMMIT;
---- ok
-STATEMENT CALL show_indexes() RETURN *;
---- 0

-CASE CreateHNSWComitRecovery
-LOAD_DYNAMIC_EXTENSION vector
-STATEMENT BEGIN TRANSACTION;
---- ok
-STATEMENT CREATE NODE TABLE embeddings (id int64, vec FLOAT[8], PRIMARY KEY (id));
---- ok
-STATEMENT COPY embeddings FROM "${RYU_ROOT_DIRECTORY}/dataset/embeddings/embeddings-8-1k.csv" (deLim=',');
---- ok
-STATEMENT CALL CREATE_VECTOR_INDEX('embeddings', 'e_hnsw_index','vec', metric := 'l2');
---- error
Binder exception: CREATE_VECTOR_INDEX is only supported in auto transaction mode.
# -STATEMENT CALL QUERY_VECTOR_INDEX('embeddings', 'e_hnsw_index',CAST([0.1521,0.3021,0.5366,0.2774,0.5593,0.5589,0.1365,0.8557],'FLOAT[8]'), 3) RETURN node.id ORDER BY distance;
# -CHECK_ORDER
# ---- 3
# 333
# 444
# 133
# -STATEMENT COMMIT;
# ---- ok
# -RELOADDB
# -STATEMENT CALL QUERY_VECTOR_INDEX('embeddings', 'e_hnsw_index',CAST([0.1521,0.3021,0.5366,0.2774,0.5593,0.5589,0.1365,0.8557],'FLOAT[8]'), 3, efs := 500) RETURN node.id ORDER BY distance;
# -CHECK_ORDER
# ---- 3
# 333
# 444
# 133

-CASE DropHNSWComitRecovery
-SKIP_IN_MEM
-LOAD_DYNAMIC_EXTENSION vector
-STATEMENT CREATE NODE TABLE embeddings (id int64, vec FLOAT[8], PRIMARY KEY (id));
---- ok
-STATEMENT COPY embeddings FROM "${RYU_ROOT_DIRECTORY}/dataset/embeddings/embeddings-8-1k.csv" (deLim=',');
---- ok
-STATEMENT CALL CREATE_VECTOR_INDEX('embeddings', 'e_hnsw_index','vec', metric := 'l2');
---- ok
-RELOADDB
-STATEMENT CALL force_checkpoint_on_close=false;
---- ok
-STATEMENT CALL auto_checkpoint=false;
---- ok
-LOAD_DYNAMIC_EXTENSION vector
-STATEMENT BEGIN TRANSACTION;
---- ok
-STATEMENT CALL DROP_VECTOR_INDEX('embeddings', 'e_hnsw_index');
---- ok
-STATEMENT COMMIT;
---- ok
-STATEMENT CALL show_indexes() RETURN *;
---- 0
-RELOADDB
-STATEMENT CALL show_tables() RETURN *;
---- 1
0|embeddings|NODE|local(ryu)|
-STATEMENT CALL show_indexes() RETURN *;
---- 0

-CASE CreateHNSWRollback
-LOAD_DYNAMIC_EXTENSION vector
-STATEMENT BEGIN TRANSACTION;
---- ok
-STATEMENT CREATE NODE TABLE embeddings (id int64, vec FLOAT[8], PRIMARY KEY (id));
---- ok
-STATEMENT COPY embeddings FROM "${RYU_ROOT_DIRECTORY}/dataset/embeddings/embeddings-8-1k.csv" (deLim=',');
---- ok
-STATEMENT CALL CREATE_VECTOR_INDEX('embeddings', 'e_hnsw_index','vec', metric := 'l2');
---- error
Binder exception: CREATE_VECTOR_INDEX is only supported in auto transaction mode.
# -STATEMENT CALL QUERY_VECTOR_INDEX('embeddings', 'e_hnsw_index',CAST([0.1521,0.3021,0.5366,0.2774,0.5593,0.5589,0.1365,0.8557],'FLOAT[8]'), 3, efs := 500) RETURN node.id ORDER BY distance;
# -CHECK_ORDER
# ---- 3
# 333
# 444
# 133
# -STATEMENT ROLLBACK;
# ---- ok
# -STATEMENT CALL SHOW_INDEXES() RETURN *;
# ---- 0

-CASE DropHNSWRollback
-LOAD_DYNAMIC_EXTENSION vector
-STATEMENT CREATE NODE TABLE embeddings (id int64, vec FLOAT[8], PRIMARY KEY (id));
---- ok
-STATEMENT COPY embeddings FROM "${RYU_ROOT_DIRECTORY}/dataset/embeddings/embeddings-8-1k.csv" (deLim=',');
---- ok
-STATEMENT CALL CREATE_VECTOR_INDEX('embeddings', 'e_hnsw_index','vec', metric := 'l2');
---- ok
-STATEMENT BEGIN TRANSACTION;
---- ok
-STATEMENT CALL DROP_VECTOR_INDEX('embeddings', 'e_hnsw_index');
---- ok
-STATEMENT ROLLBACK;
---- ok
-STATEMENT CALL show_indexes() RETURN *;
---- 1
embeddings|e_hnsw_index|HNSW|[vec]|True|CALL CREATE_VECTOR_INDEX('embeddings', 'e_hnsw_index', 'vec', mu := 30, ml := 60, pu := 0.050000, metric := 'l2', alpha := 1.100000, efc := 200);

# TODO(Guodong): Uncomment this when we support CREATE_VECTOR_INDEX in the manual transaction mode.
# -CASE CreateHNSWRollbackRecovery
# -SKIP_IN_MEM
# -STATEMENT LOAD EXTENSION '${RYU_ROOT_DIRECTORY}/extension/vector/build/libvector.ryu_extension';
# ---- ok
# -STATEMENT BEGIN TRANSACTION;
# ---- ok
# -STATEMENT CREATE NODE TABLE embeddings (id int64, vec FLOAT[8], PRIMARY KEY (id));
# ---- ok
# -STATEMENT COPY embeddings FROM "${RYU_ROOT_DIRECTORY}/dataset/embeddings/embeddings-8-1k.csv" (deLim=',');
# ---- ok
# -STATEMENT CALL CREATE_VECTOR_INDEX('embeddings', 'e_hnsw_index','vec', metric := 'l2');
# ---- error
# Binder exception: CREATE_VECTOR_INDEX is only supported in auto transaction mode.
# -STATEMENT CALL QUERY_VECTOR_INDEX('embeddings', 'e_hnsw_index',CAST([0.1521,0.3021,0.5366,0.2774,0.5593,0.5589,0.1365,0.8557],'FLOAT[8]'), 3, efs := 500) RETURN node.id ORDER BY distance;
# -CHECK_ORDER
# ---- 3
# 333
# 444
# 133
# -STATEMENT ROLLBACK;
# ---- ok
# -STATEMENT CALL SHOW_INDEXES() RETURN *;
# ---- 0
# -RELOADDB
# -STATEMENT CALL SHOW_INDEXES() RETURN *;
# ---- 0

-CASE DropHNSWRollbackRecovery
-SKIP_IN_MEM
-LOAD_DYNAMIC_EXTENSION vector
-STATEMENT CREATE NODE TABLE embeddings (id int64, vec FLOAT[8], PRIMARY KEY (id));
---- ok
-STATEMENT COPY embeddings FROM "${RYU_ROOT_DIRECTORY}/dataset/embeddings/embeddings-8-1k.csv" (deLim=',');
---- ok
-STATEMENT CALL CREATE_VECTOR_INDEX('embeddings', 'e_hnsw_index','vec', metric := 'l2');
---- ok
-RELOADDB
-STATEMENT CALL force_checkpoint_on_close=false;
---- ok
-STATEMENT CALL auto_checkpoint=false;
---- ok
-LOAD_DYNAMIC_EXTENSION vector
-STATEMENT BEGIN TRANSACTION;
---- ok
-STATEMENT CALL DROP_VECTOR_INDEX('embeddings', 'e_hnsw_index');
---- ok
-STATEMENT ROLLBACK;
---- ok
-STATEMENT CALL show_indexes() RETURN table_name, index_name, index_type, property_names;
---- 1
embeddings|e_hnsw_index|HNSW|[vec]
-RELOADDB
-STATEMENT CALL show_indexes() RETURN table_name, index_name, index_type, property_names;
---- 1
embeddings|e_hnsw_index|HNSW|[vec]

-CASE InsertRecovery
-SKIP_IN_MEM
-LOAD_DYNAMIC_EXTENSION vector
-STATEMENT CREATE NODE TABLE embeddings (id int64, vec FLOAT[8], PRIMARY KEY (id));
---- ok
-STATEMENT CALL threads=1;
---- ok
-STATEMENT COPY embeddings FROM "${RYU_ROOT_DIRECTORY}/dataset/embeddings/embeddings-8-1k.csv" (deLim=',');
---- ok
-STATEMENT CALL CREATE_VECTOR_INDEX('embeddings', 'e_hnsw_index','vec', metric := 'l2');
---- ok
-STATEMENT CALL QUERY_VECTOR_INDEX('embeddings', 'e_hnsw_index', [0.1521,0.3021,0.5366,0.2774,0.5593,0.5589,0.1365,0.8557], 3, efs := 500) RETURN node.id ORDER BY distance;
-CHECK_ORDER
---- 3
333
444
133
-RELOADDB
-STATEMENT CALL force_checkpoint_on_close=false;
---- ok
-STATEMENT CALL auto_checkpoint=false;
---- ok
-LOAD_DYNAMIC_EXTENSION vector
-STATEMENT CREATE (t:embeddings {id: 1000, vec: [0.1521,0.3021,0.5366,0.2774,0.5593,0.5589,0.1365,0.8557]});
---- ok
-STATEMENT CALL QUERY_VECTOR_INDEX('embeddings', 'e_hnsw_index', [0.1521,0.3021,0.5366,0.2774,0.5593,0.5589,0.1365,0.8557], 3, efs := 500) RETURN node.id ORDER BY distance;
-CHECK_ORDER
---- 3
1000
333
444
-RELOADDB
-STATEMENT CALL QUERY_VECTOR_INDEX('embeddings', 'e_hnsw_index', [0.1521,0.3021,0.5366,0.2774,0.5593,0.5589,0.1365,0.8557], 3, efs := 500) RETURN node.id ORDER BY distance;
-CHECK_ORDER
---- 3
1000
333
444

-CASE MultipleInsertionsRecovery
-SKIP_IN_MEM
-STATEMENT CALL force_checkpoint_on_close=false;
---- ok
-STATEMENT CALL auto_checkpoint=false;
---- ok
-LOAD_DYNAMIC_EXTENSION vector
-STATEMENT CREATE NODE TABLE embeddings (id int64, vec FLOAT[8], PRIMARY KEY (id));
---- ok
-STATEMENT CALL CREATE_VECTOR_INDEX('embeddings', 'e_hnsw_index','vec', metric := 'l2');
---- ok
-RELOADDB
-STATEMENT CALL force_checkpoint_on_close=false;
---- ok
-STATEMENT CALL auto_checkpoint=false;
---- ok
-LOAD_DYNAMIC_EXTENSION vector
-STATEMENT CALL threads=1;
---- ok
-STATEMENT load from '${RYU_ROOT_DIRECTORY}/dataset/embeddings/embeddings-8-1k.csv' with column0 as c0, column1 as c1 limit 500 CREATE (:embeddings {id: c0, vec: c1});
---- ok
-RELOADDB
-STATEMENT CALL threads=1;
---- ok
-STATEMENT load from '${RYU_ROOT_DIRECTORY}/dataset/embeddings/embeddings-8-1k.csv' with column0 as c0, column1 as c1 skip 500 limit 500 CREATE (:embeddings {id: c0, vec: c1});
 ---- ok
-STATEMENT CALL QUERY_VECTOR_INDEX('embeddings', 'e_hnsw_index', [0.1521,0.3021,0.5366,0.2774,0.5593,0.5589,0.1365,0.8557], 3, efs := 500) RETURN node.id ORDER BY distance;
-CHECK_ORDER
---- 3
333
444
133

-CASE DeleteRecovery
-SKIP_IN_MEM
-LOAD_DYNAMIC_EXTENSION vector
-STATEMENT CREATE NODE TABLE embeddings (id int64, vec FLOAT[8], PRIMARY KEY (id));
---- ok
-STATEMENT CALL threads=1;
---- ok
-STATEMENT COPY embeddings FROM "${RYU_ROOT_DIRECTORY}/dataset/embeddings/embeddings-8-1k.csv" (deLim=',');
---- ok
-STATEMENT CALL CREATE_VECTOR_INDEX('embeddings', 'e_hnsw_index','vec', metric := 'l2');
---- ok
-RELOADDB
-STATEMENT CALL force_checkpoint_on_close=false;
---- ok
-STATEMENT CALL auto_checkpoint=false;
---- ok
-LOAD_DYNAMIC_EXTENSION vector
-STATEMENT CALL QUERY_VECTOR_INDEX('embeddings', 'e_hnsw_index', [0.1521,0.3021,0.5366,0.2774,0.5593,0.5589,0.1365,0.8557], 3, efs := 500) RETURN node.id ORDER BY distance;
-CHECK_ORDER
---- 3
333
444
133
-STATEMENT MATCH (e:embeddings) WHERE e.id = 333 DELETE e;
---- ok
-STATEMENT CALL QUERY_VECTOR_INDEX('embeddings', 'e_hnsw_index', [0.1521,0.3021,0.5366,0.2774,0.5593,0.5589,0.1365,0.8557], 3, efs := 500) RETURN node.id ORDER BY distance;
-CHECK_ORDER
---- 3
444
133
598
-RELOADDB
-STATEMENT CALL force_checkpoint_on_close=false;
---- ok
-STATEMENT CALL auto_checkpoint=false;
---- ok
-STATEMENT CALL QUERY_VECTOR_INDEX('embeddings', 'e_hnsw_index', [0.1521,0.3021,0.5366,0.2774,0.5593,0.5589,0.1365,0.8557], 3, efs := 500) RETURN node.id ORDER BY distance;
-CHECK_ORDER
---- 3
444
133
598
-STATEMENT MATCH (e:embeddings) WHERE e.id = 444 DELETE e;
---- ok
-STATEMENT CALL QUERY_VECTOR_INDEX('embeddings', 'e_hnsw_index', [0.1521,0.3021,0.5366,0.2774,0.5593,0.5589,0.1365,0.8557], 3, efs := 500) RETURN node.id ORDER BY distance;
-CHECK_ORDER
---- 3
133
598
225
-RELOADDB
-STATEMENT CALL QUERY_VECTOR_INDEX('embeddings', 'e_hnsw_index', [0.1521,0.3021,0.5366,0.2774,0.5593,0.5589,0.1365,0.8557], 3, efs := 500) RETURN node.id ORDER BY distance;
-CHECK_ORDER
---- 3
133
598
225

-CASE DeleteBulkRecovery
-SKIP_IN_MEM
-LOAD_DYNAMIC_EXTENSION vector
-STATEMENT CREATE NODE TABLE embeddings (id int64, vec FLOAT[8], PRIMARY KEY (id));
---- ok
-STATEMENT CALL threads=1;
---- ok
-STATEMENT COPY embeddings FROM "${RYU_ROOT_DIRECTORY}/dataset/embeddings/embeddings-8-1k.csv" (deLim=',');
---- ok
-STATEMENT CALL CREATE_VECTOR_INDEX('embeddings', 'e_hnsw_index','vec', metric := 'l2');
---- ok
-RELOADDB
-STATEMENT CALL force_checkpoint_on_close=false;
---- ok
-STATEMENT CALL auto_checkpoint=false;
---- ok
-LOAD_DYNAMIC_EXTENSION vector
-STATEMENT CALL QUERY_VECTOR_INDEX('embeddings', 'e_hnsw_index', [0.1521,0.3021,0.5366,0.2774,0.5593,0.5589,0.1365,0.8557], 3, efs := 500) RETURN node.id ORDER BY distance;
-CHECK_ORDER
---- 3
333
444
133
-STATEMENT MATCH (e:embeddings) WHERE e.id <=200 DELETE e;
---- ok
-STATEMENT CALL QUERY_VECTOR_INDEX('embeddings', 'e_hnsw_index', [0.1521,0.3021,0.5366,0.2774,0.5593,0.5589,0.1365,0.8557], 3, efs := 500) RETURN node.id ORDER BY distance;
-CHECK_ORDER
---- 3
333
444
598
-RELOADDB
-STATEMENT CALL QUERY_VECTOR_INDEX('embeddings', 'e_hnsw_index', [0.1521,0.3021,0.5366,0.2774,0.5593,0.5589,0.1365,0.8557], 3, efs := 500) RETURN node.id ORDER BY distance;
-CHECK_ORDER
---- 3
333
444
598

-CASE UpdateAfterDropIndex
-SKIP_IN_MEM
-LOAD_DYNAMIC_EXTENSION vector
-STATEMENT CREATE NODE TABLE Person(id STRING, name STRING, embeddings FLOAT[8], PRIMARY KEY(id));
---- ok
-STATEMENT CREATE (p:Person {id: "person-1", name: "Alice", embeddings: [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8]});
---- ok
-STATEMENT CALL CREATE_VECTOR_INDEX('Person', 'person_embeddings_idx', 'embeddings', metric := 'cosine');
---- ok
-STATEMENT CALL SHOW_INDEXES() RETURN table_name, index_name;
---- 1
Person|person_embeddings_idx
-STATEMENT CALL DROP_VECTOR_INDEX('Person', 'person_embeddings_idx');
---- ok
-STATEMENT CALL SHOW_INDEXES() RETURN *;
---- 0
-STATEMENT MATCH (p:Person {id: "person-1"}) SET p.embeddings = [0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9] RETURN p.id;
---- 1
person-1
-STATEMENT MATCH (p:Person {id: "person-1"}) RETURN p.embeddings;
---- 1
[0.200000,0.300000,0.400000,0.500000,0.600000,0.700000,0.800000,0.900000]
-RELOADDB
-STATEMENT MATCH (p:Person {id: "person-1"}) SET p.embeddings = [0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0] RETURN p.id;
---- 1
person-1
-STATEMENT MATCH (p:Person {id: "person-1"}) RETURN p.embeddings;
---- 1
[0.300000,0.400000,0.500000,0.600000,0.700000,0.800000,0.900000,1.000000]

-CASE MergeAfterDropIndex
-SKIP_IN_MEM
-LOAD_DYNAMIC_EXTENSION vector
-STATEMENT CREATE NODE TABLE Organization(id STRING, name STRING, embeddings FLOAT[8], PRIMARY KEY(id));
---- ok
-STATEMENT CREATE (o:Organization {id: "org-1", name: "Company", embeddings: [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8]});
---- ok
-STATEMENT CALL CREATE_VECTOR_INDEX('Organization', 'org_embeddings_idx', 'embeddings', metric := 'l2');
---- ok
-STATEMENT CALL DROP_VECTOR_INDEX('Organization', 'org_embeddings_idx');
---- ok
-STATEMENT MERGE (o:Organization {id: "org-1"}) SET o.embeddings = [0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2] RETURN o.id;
---- 1
org-1
-STATEMENT MATCH (o:Organization {id: "org-1"}) RETURN o.embeddings;
---- 1
[0.500000,0.600000,0.700000,0.800000,0.900000,1.000000,1.100000,1.200000]
-STATEMENT MERGE (o:Organization {id: "org-2"}) ON CREATE SET o.name = "NewOrg", o.embeddings = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8] RETURN o.id;
---- 1
org-2
-RELOADDB
-STATEMENT MATCH (o:Organization) RETURN o.id, o.embeddings ORDER BY o.id;
---- 2
org-1|[0.500000,0.600000,0.700000,0.800000,0.900000,1.000000,1.100000,1.200000]
org-2|[0.100000,0.200000,0.300000,0.400000,0.500000,0.600000,0.700000,0.800000]
